\input texinfo
@c -*-texinfo-*-

@c %**start of header
@setfilename gwl.info
@documentencoding UTF-8
@settitle Guix Workflow Language Reference Manual
@c %**end of header

@include version.texi

@copying
Copyright @copyright{} 2018 Roel Janssen@*
Copyright @copyright{} 2018, 2019, 2020, 2021 Ricardo Wurmus

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end copying

@dircategory Scientific Computing
@direntry
* Guix Workflow Language: (gwl).  Reproducible Scientific Workflows based on Guix.
@end direntry

@titlepage
@title Guix Workflow Language Reference Manual
@subtitle Reproducible Scientific Workflows based on Guix
@author The developers of the GNU Guix Workflow Language

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@value{UPDATED} @*

@insertcopying
@end titlepage

@contents

@c *********************************************************************
@node Top
@top Guix Workflow Language

This document describes the Guix Workflow Language version @value{VERSION}.

@menu
* Introduction::                What is this all about?
* Installation::                Installing the GWL.
* A Simple Workflow::           Show me what this looks like!
* Defining a Process::          What's in a process?
* Code Snippets::               Embedding scripts.
* Defining a Workflow::         Combine processes to build a workflow.
* Process Engines::             Generating executable pipeline scripts.
* Invoking guix workflow::      Running workflows.

* Acknowledgments::             Thanks!
* GNU Free Documentation License::  The license of this manual.
* Concept Index::               Concepts.
* Programming Index::           Data types, functions, and variables.
@end menu

@c *********************************************************************
@node Introduction
@chapter Introduction

This package provides the @dfn{Guix Workflow Language} (GWL), a
scientific computing extension to the Guix package manager.  It
combines the specification of work units and their relationship to one
another with the reproducible software deployment facilities of the
functional package manager GNU Guix.  A GWL workflow will always run
in a reproducible environment that GNU Guix automatically prepares.
The GWL extends your Guix installation with a single new sub-command:
@code{guix workflow}.

In the GWL there are two concepts we need to know about: processes and
workflows.  We describe a computation (running a program, or
evaluating a Scheme expression) using a process.  A workflow describes
how individual processes relate to each other (e.g. ``process B must
run after process A, and process C must run before process A'').

GWL workflows are executable code.  The workflow language is embedded
in the powerful general purpose language
@url{https://gnu.org/software/guile/, Guile Scheme}, so you can
compute arbitrarily complex process and workflow definitions.  The GWL
supports a classic Lisp syntax as well as a Python-like syntax called
@url{https://www.draketo.de/light/english/wisp-lisp-indentation-preprocessor,Wisp}.

@c *********************************************************************
@node Installation
@chapter Installation

There really is no point in using the GWL without Guix.  If you
already have a Guix installation, you can install the GWL with
@code{guix install gwl}.

The Guix Workflow Language uses the GNU build system.  To install it
from a release tarball just unpack it and run the usual commands:

@cindex installing from source
@cindex building from source
@example
./configure
make
make install
@end example

If you want to build the sources from the source repository you need to
bootstrap the build system first.  Run @code{autoreconf -vif} first and
then perform the above steps.

Note that in order for Guix to learn about the ``workflow''
sub-command provided by the GWL, the Guile module @code{(guix scripts
workflow)} must be found in a directory on the @code{GUIX_EXTENSIONS_PATH}.

@c *********************************************************************
@node A Simple Workflow
@chapter A Simple Workflow

To get a little taste of what the workflow language looks like, let's
start by writing a simple workflow.

Here is a simple workflow example:

@lisp
@verbatiminclude examples/simple-wisp.w
@end lisp

This white-space sensitive syntax is called Wisp and if you're familiar
with Python or YAML you should feel right at home.  To use this syntax
simply save your workflow to a file ending on @file{.w}, @file{.wisp},
or @file{.gwl}.

The workflow language really is a @dfn{domain specific language} (DSL)
embedded in Guile Scheme, so if you're a Lisper you may prefer to write
your workflows directly in Scheme while basking in its parenthetical
glow:

@lisp
@verbatiminclude examples/simple.scm
@end lisp

Everything you can express in Scheme can also be expressed with the Wisp
syntax, so the choice is down to personal preference.

@c *********************************************************************
@node Defining a Process
@chapter Defining a Process

@cindex defining processes
In the GWL a ``process'' is a combination of some kind of command or
script to be executed, the software packages that need to be available
when executing the commands, and declarations of inputs and generated
outputs.  A process has a name, and optionally a synopsis and a
description, for display purposes.

@cindex make-process, constructor
We create a process with the @code{make-process} constructor like
this:

@lisp
make-process
  name "hello"
  procedure
     ' display "hello"
@end lisp

This creates a process with the name ``hello'', which will print the
string @code{"hello"} once the process is executed.  The
@code{procedure} field holds the Scheme code that does all the work of
saying ``hello''.  We will talk about the @code{procedure} field a
little later and show how to write code snippets in languages other
than Scheme.

Often we will want to refer to previously created processes later, for
example to combine them in a workflow definition.  To do that we need
to bind the created processes to variable names.  Here we bind the
above process to a variable named @code{hello}:

@lisp
define hello
  make-process
    name "hello"
    procedure
       ' display "hello"
@end lisp

@cindex process, constructor
@cindex process, definition macro
This is a very common thing to do, so the GWL offers a shorter syntax
for not only creating a process but also binding it to a variable.
The following example is equivalent to the above definition:

@lisp
process hello
  procedure
     ' display "hello"
@end lisp


@node @code{process} Fields
@section @code{process} Fields
@cindex process, valid fields
Both @code{make-process} and @code{process} accept the same fields,
which we describe below.

@table @code
@cindex name, process field
@item name
The readable name of the process as a string.  This is used for
display purposes and to select processes by name.  When the
@code{process} constructor is used, the @code{name} field need not be
provided explicitly.

@cindex version, process field
@item version
This field holds an arbitrary version string.  This can be used to
disambiguate between different implementations of a process when
searching by name.

@cindex synopsis, process field
@item synopsis
A short summary of what this process intends to accomplish.

@cindex description, process field
@item description
A longer description about the purpose of this process.

@cindex packages, process field
@item packages
This field is used to specify what software packages need to be
available when executing the process.  Packages can either be Guix
package specifications --- such as the string @code{"guile@@3.0"} for
Guile version 3.0 --- or package variable names.

@cindex packages, looked up in inferior Guix
@cindex packages, using current Guix
By default, package specifications are looked up in the context of the
current Guix, i.e. the same version of Guix that you used to invoke
@command{guix workflow}.  This is to ensure that you get exactly those
packages that you would expect given the Guix channels you have
configured.

@cindex packages, using Guix modules
We strongly advise against using package variables from Guix modules.
The workflow language uses Guix as a library and is compiled and
tested with the version of Guix that is currently available as the
@code{guix} package in @code{(gnu packages package-management)}.  The
version of this Guix will likely be older than the version of Guix you
use to invoke @command{guix workflow}.

@cindex packages, from channels
Package variables are useful for one-off ad-hoc packages that are not
contained in any channel and are defined in the workflow file itself.
You suggest you use the procedure @code{lookup-package} from the
@code{(gwl packages)} module to look up inputs in the context of the
current Guix.  To ensure reproducibility, however, we urge you to
publish packages in a version-controlled channel.  See the Guix
reference manual to learn all there is to know about channels.

@cindex implicit list, process.packages
The @code{packages} field accepts a list of packages as well as
multiple values (an ``implicit list'').  All of the following
specifications are valid.  A single package:

@lisp
process
  packages "guile"
  @dots{}
@end lisp

More than one package:

@lisp
process
  packages "guile" "python"
  @dots{}
@end lisp

A single list of packages:

@lisp
process
  packages
    list "guile" "python"
  @dots{}
@end lisp

@cindex inputs, process field
@item inputs
This field holds inputs to the process.  Commonly, this will be a list
of file names that the process requires to be present.  The GWL can
automatically connect processes by matching up their declared inputs
and outputs, so that processes generating certain outputs are executed
before those that declare the same item as an input.

As with the @code{packages} field, the @code{inputs} field accepts an
``implicit list'' of multiple values as well as an explicit list.
@cindex tagged lists
@cindex named items, lists
@cindex tagged items, lists
Additionally, individual inputs can be ``tagged'' or named by
prefixing it with a keyword (@pxref{Keywords,,,guile,GNU Guile
Reference Manual}).  Here's an example of an implicit list of inputs
spread across multiple lines where two inputs have been tagged:

@lisp
process
  inputs
    . genome: "hg19.fa"
    . "cookie-recipes.txt"
    . samples: "foo.fq"
  @dots{}
@end lisp

The leading period is Wisp syntax to continue the previous line.  You
can, of course, do without the periods, but this may look a little
more cluttered:

@lisp
process
  inputs genome: "hg19.fa" "cookie-recipes.txt" samples: "foo.fq"
  @dots{}
@end lisp

@cindex pick, items from a tagged list
@cindex select, tagged items in a list
Why tag inputs at all?  Because you can reference them in other parts
of your process definition without having to awkwardly traverse the
whole list of inputs.  Here is one way to select the first input that
was tagged with the @code{samples:} keyword:

@lisp
pick genome: inputs
@end lisp

To select the second item after the tag @code{genome:} do this:

@lisp
pick second genome: inputs
@end lisp

or using a numerical zero-based index:

@lisp
pick 1 genome: inputs
@end lisp

@ref{Code Snippets} for a convenient way to access named items in code
snippets without having to define your picks beforehand.

@cindex process-inputs, procedure
@cindex getting process inputs
The procedure @code{process-inputs} can be used to access the list of
inputs of any given process.  By default, tags are removed from the
list.  If you want to include tags (e.g. to select specific inputs
with @code{pick}), you can pass the keyword @code{with-tags}.

Here is an example of two processes where the second process refers to
the inputs of the first.

@lisp
process count-reads (with sample)
  packages
    . "r-minimal"
  inputs
    . bam:
    file sample "_Aligned.sortedByCoord.out.bam"
    . bai:
    file sample "_Aligned.sortedByCoord.out.bam.bai"
    . script:
    file "count-reads.R"
  outputs
    file sample ".read_counts.csv"
  # @{
    R @{@{inputs:script@}@} @{@{inputs:bam@}@} @{@{inputs:bai@}@} > @{@{outputs@}@}
  @}

process genome-coverage (with sample)
  packages
    . "r-minimal"
  inputs
    define other-inputs
      process-inputs
        count-reads sample with-tags:
    . files:
    pick bam: others
    pick bai: others
    . script:
    file "genome-coverage.R"
  outputs
    files sample / (list ".forward" ".reverse") ".bigwig"
  # @{
    R @{@{inputs:script@}@} @{@{inputs::files@}@} > @{@{outputs@}@}
  @}
@end lisp


@cindex outputs, process field
@item outputs
This field holds a list of outputs that are expected to appear after
executing the process.  Usually this will be a list of file names.
Just like the @code{inputs} field, this field accepts a plain list, an
implicit list of one or more values, and lists with named items.

The GWL can automatically connect processes by matching up their
declared inputs and outputs, so that processes generating certain
outputs are executed before those that declare the same item as an
input.

@cindex process-outputs, procedure
@cindex getting process outputs
The procedure @code{process-outputs} can be used to access the list of
outputs of any given process.  By default, tags are removed from the
list.  If you want to include tags (e.g. to select specific outputs
with @code{pick}), you can pass the keyword @code{with-tags}.

Here is an example of two processes where the second process refers to
the outputs of the first.

@lisp
process one
  packages
    . "coreutils"
  inputs
    . "input.txt"
  outputs
    . log: "first.log"
    . text: "first.txt"
  # @{ tail @{@{inputs@}@} > @{@{outputs:text@}@} @}

process two
  packages
    . "coreutils"
  inputs
    pick text:
      process-outputs one with-tags:
  outputs
    . done: "second.txt"
    . log: "second.log"
  # @{ head @{@{inputs@}@} > @{@{outputs:done@}@} @}
@end lisp

@cindex output-path, process field
@item output-path
This is a directory prefix for all outputs.

@cindex run-time, process field
@item run-time
This field is used to specify run-time resource estimates, such as the
memory requirement of the process or the maximum time it should run.
This is especially useful when submitting jobs to an HPC cluster
scheduler such as Grid Engine, as these schedulers may give higher
priority to jobs that declare a short run time.

@cindex time, complexity
@cindex space, complexity
@cindex threads, complexity
@cindex seconds, run-time specification
@cindex minutes, run-time specification
@cindex hours, run-time specification
@cindex kibibytes, memory specification
@cindex kilobytes, memory specification
@cindex mebibytes, memory specification
@cindex megabytes, memory specification
@cindex gibibytes, memory specification
@cindex gigabytes, memory specification
Resources are specified as a complexity value with the fields
@code{space} (for memory requirements), @code{time} (for the expected
duration of the computation), and @code{threads} (to control the
number of CPU threads).  For convenience, memory requirements can be
specified with the units @code{kibibytes} (or @code{KiB}),
@code{mebibytes} (or @code{MiB}), or @code{gibibytes} (or @code{GiB}).
Supported time units are @code{seconds}, @code{minutes}, and
@code{hours}.

Here is an example of a single-threaded process that is granted 20 MiB
of run-time memory for a duration of 10 seconds:

@lisp
process stamp-inputs
  inputs "first" "second" "third"
  outputs "inputs.txt"
  run-time
    complexity
      space 20 mebibytes
      time  10 seconds
      threads 1
  # @{ echo @{@{inputs@}@} > @{@{outputs@}@} @}
@end lisp

When this process is executed by a scheduler that honors resource
limits, the process will be granted at most 20 MiB of memory and will
be killed if it has not concluded after 10 seconds.

@cindex values, process field
@item values
This field holds a list with keyword-tagged items that can be used in
code snippets.  Values defined here are passed to the process script
at execution time (rather than preparation time), so this field can be
used to avoid embedding literal values in code snippets when
generating processes from a template.  To learn more about code
snippets @ref{Code Snippets}.

Here is a simple example of a process template with values:

@lisp
process greet (with name)
  packages
    . "hello"
    . "coreutils"
  outputs
    file name ".txt"
  values
    . capitalized:
    string-upcase name
  # @{
    echo "This is a greeting for @{@{values:capitalized@}@}."
    hello >> @{@{outputs@}@}
  @}

map greet
  list "rekado" "civodul" "zimoun"
@end lisp

The generated script from this process does not embed any specific
value for @code{name} or even @code{capitalized}.  Instead it looks up
the value for @code{capitalized} in the arguments passed to the script
at execution time.  So instead of generating three scripts that only
differ in one value (the capitalized name), the GWL will only generate
@emph{one} script and pass it three different values for the three
processes.

For another example and further discussion of embedding values versus
referencing them at execution time @ref{Process templates}.

@cindex procedure, process field
@item procedure
This field holds an expression of code that should be run when the
process is executed.  This is the ``work'' that a process should
perform.  By default that's a quoted Scheme expression, but code
snippets in other languages are also supported (@pxref{Code
Snippets}).

Here's an example of a process with a procedure that writes a haiku to
a file:

@lisp
@verbatiminclude examples/haiku.w
@end lisp

The Scheme expression here is quasiquoted (with a leading @code{`}) to
allow for unquoting (with @code{,}) of variables, such as
@code{outputs}.

Not always will Scheme be the best choice for a process procedure.
Sometimes all you want to do is fire off a few shell commands.  While
this is, of course, possible to express in Scheme, it is admittedly
somewhat verbose.  For convenience we offer a simple and surprisingly
short syntax for this common use case.  As a bonus you can even leave
off the field name ``procedure'' and write your code snippet right
there.  How?  @ref{Code Snippets}.
@end table

@c TODO: document the accessor procedures

@node Process templates
@section Process templates
@cindex process templates
@cindex generating processes

When defining many similar processes, it can be useful to parameterize
a single process template.  This can be accomplished by defining a
procedure that takes any number of arguments and returns a
parameterized process.  Here's how to do this somewhat verbosely in
plain Scheme:

@lisp
(define (build-me-a-process thing)
  "Return a process that displays THING."
  (make-process
    (name (string-append "show-" thing))
    (procedure `(display ,thing))))

;; Now use this procedure to build concrete processes.
(define show-fruit
  (build-me-a-process "fruit"))
(define show-kitchen
  (build-me-a-process "kitchen"))
(define show-table
  (build-me-a-process "table"))
@end lisp

As this is a somewhat common thing to do in real workflows, the GWL
provides simplified syntax to express the same concepts with a little
less effort:

@lisp
process build-me-a-process (with thing)
  name
    string-append "show-" thing
  procedure
    ` display ,thing

define show-fruit
  build-me-a-process "fruit"
define show-kitchen
  build-me-a-process "kitchen"
define show-table
  build-me-a-process "table"
@end lisp

The result is the same: you get a procedure @code{build-me-a-process}
that you can use to define a number of similar processes.  In the end
you have the three processes @code{show-fruit}, @code{show-kitchen},
and @code{show-table}.

@cindex reusing process scripts
@cindex values, process field (example)
In a real-life workflow, the above example would not be very
efficient.  The GWL generates an executable script for every process,
passing the process properties (such as @code{name}, @code{inputs},
@code{outputs}, etc) as arguments.  It is a good idea to only generate
one script per process @emph{template} instead of producing one script
per process, as this @emph{vastly} reduces preparation work that the
GWL has to perform.

The GWL can arrange for scripts to be reused as long as you take care
not to embed arbitrary variables in the process @code{procedure}
field.  To this end the GWL offers the @code{values} field for
arbitrary value definitions that should be passed to process scripts
as arguments.

Another thing to avoid is to make the process name dependent on
template arguments.  This prevents script reuse as the GWL is forced
to generate scripts that are virtually identical except for their
names.  Here's an example with ten processes that all share the same
process script:

@lisp
define LOG_DIR
  file "logs"

define SAMPLES
  list
    . "first-sample"
    . "second"
    . "third-sample"
    . "sample-no4"
    . "take-five"
    . "666"
    . "se7en"
    . "who-eight-nine?"
    . "NEIN!"
    reverse-string "net"

process index-bam (with sample)
  inputs
    file "mapped-reads" / sample "_Aligned.sortedByCoord.out.bam"
  outputs
    . bai:
    file "mapped-reads" / sample "_Aligned.sortedByCoord.out.bam.bai"
    . log:
    file LOG_DIR / "samtools_index_" sample ".log"
  packages
    . "samtools"
    . "coreutils"
  values
    . sample-id: sample
    . backwards:
    string-reverse
      first inputs
  # @{
    mkdir -p @{@{LOG_DIR@}@}
    echo "The sample identifier is @{@{values:sample-id@}@}"
    samtools index @{@{inputs@}@} @{@{outputs:bai@}@} >> @{@{outputs:log@}@} 2>&1
    echo "By the way, the sample's file name in reverse is @{@{values:backwards@}@}."
  @}

workflow test
  processes
    map index-bam SAMPLES
@end lisp

Here the value of the variable @code{LOG_DIR} is embedded in the
generated script, but that's fine because it is independent of the
template argument @code{sample}.  While we could have used
@code{sample} directly, we instead defined it as a value in the
@code{values} field and tagged it with the keyword @code{sample-id:}.
For the fun of it we also defined a value with the tag
@code{backwards:}, which is defined in terms of another process field
(@code{inputs}).

References to the fields @code{inputs}, @code{outputs}, @code{name},
and @code{values} are resolved via arguments passed to the process
script at execution time.  They do not interfere with script reuse as
their values are not embedded in the generated script.


@node Useful procedures and macros
@section Useful procedures and macros
@cindex (gwl utils)
@cindex Helper procedures
@cindex Helper macros
@cindex Utilities

The @code{(gwl utils)} module provides a number of useful helpers that
are intended to simplify common tasks when defining processes.  The
helpers defined by this module are all available by default.

@cindex on, helper procedure
@cindex reorder higher order function application
@deffn {Scheme Procedure} on @var{collection} @var{higher} @var{proc}
The @code{on} procedure is an alternative way to express the
application of a higher order function to some collection.  The only
purpose of this procedure is to improve legibility when using Wisp
syntax, as it allows one to avoid leading dots.  The following two
expressions are equivalent:

@lisp
;; With "on"
on numbers map
   lambda (number)
     + number 10

;; Without "on"
map
  lambda (number)
    + number 10
  . samples
@end lisp
@end deffn

@cindex file, helper macro
@cindex construct a single file name
@deffn {Scheme Macro} file @var{file-name-part}@dots{}
This macro enables you to construct a normalized file name out of any
number of file name parts given as arguments.  A file name part can
either be a string literal or a variable or expression that evaluates
to a string.

Directories are separated with a literal slash.  This allows you to
construct file names where parts of a directory or file name are
computed from other values.

@lisp
define user
  . "rekado"

define my-list
  iota 32

define num
  number->string
    + 10
      length my-list

file / "home" / user / "file_" num ".txt"

=> "/home/rekado/file_42.txt"
@end lisp
@end deffn

@cindex files, helper macro
@cindex construct multiple file names
@cindex file name expansion
@deffn {Scheme Macro} files @var{file-name-part}@dots{}
Much like the @code{file} macro, the @code{files} macro enables you to
construct multiple normalized file names out of any number of file
name parts given as arguments.  A file name part can either be a
string literal, a variable or expression that evaluates to a string,
or a variable or expression that evaluates to a list of strings.

Any list of strings will lead to the construction of a combinatorial
variant.  This is very useful when you need to generate a list of
input or output file names.

Directories are separated with a literal slash.  This allows you to
construct file names where parts of a directory or file name are
computed from other values.

@lisp
define users
  list "rekado" "zimoun"

define projects
  list "foo" "bar"

define extensions
  list "txt" "tar.gz" "scm"

files / "home" / users / "proj_" projects / "file." extensions

=> '("/home/rekado/proj_foo/file.txt"
     "/home/rekado/proj_foo/file.tar.gz"
     "/home/rekado/proj_foo/file.scm"
     "/home/rekado/proj_bar/file.txt"
     "/home/rekado/proj_bar/file.tar.gz"
     "/home/rekado/proj_bar/file.scm"
     "/home/zimoun/proj_foo/file.txt"
     "/home/zimoun/proj_foo/file.tar.gz"
     "/home/zimoun/proj_foo/file.scm"
     "/home/zimoun/proj_bar/file.txt"
     "/home/zimoun/proj_bar/file.tar.gz"
     "/home/zimoun/proj_bar/file.scm")
@end lisp
@end deffn

@cindex pick, helper procedure
@cindex pick elements from a list
@cindex select tagged items
@deffn {Scheme Procedure} pick [@var{n}] @var{key} @var{collection}
This procedure allows you to pick a named item from a @var{collection}
by looking for the specified keyword @var{key}.  Optionally, you can
provide a selector procedure or index @var{n} as the first argument.
Without a selector the first item matching the given @var{key} will be
returned.  When the selector is @code{*} all items following the
@var{key} (up to the next tag) will be returned.  If the selector is a
number it is used as a zero-based index into the list of items
following the @var{key}.  If the selector is a procedure it is applied
to the list of items following the @var{key}.

@lisp
define collection
  list
    . "one"
    . "two"
    . "three"
    . mine: "four"
    . "five"
    . yours: "six"

pick mine: collection

; => "four"

pick * mine: collection

; => '("four" "five")

pick second mine: collection

; => "five"

pick 0 yours: collection

; => "six"
@end lisp
@end deffn

@cindex load-workflow
@cindex load a workflow
@deffn {Scheme Syntax} load-workflow @var{file}
This macro lets you load a workflow from the given @var{file}.  The
file must evaluate to a workflow value.  This macro is useful for when
you want to extend previously defined workflows.  The argument
@var{file} is expected to be a file name relative to the file invoking
@code{load-workflow}.
@end deffn


@cindex get, helper procedure
@cindex get elements from a nested association list
@cindex get elements from a nested collection
@cindex look up values in dictionaries
@cindex look up configuration values
@deffn {Scheme Procedure} get @var{collection} [#:default @var{default}] @var{path}@dots{}

This procedure allows you to select an item from a (potentially
nested) @var{collection} by traversing the specified @var{path}, a
sequence of string or symbols that are keys in the collection.  This
becomes much clearer with an example:

@lisp
(define config
  '(("locations"
     . (("input"  . "/home/rekado/foo")
        ("output" . "/dev/null")))
    ("resources"
     . (("R"
         . (("memory" . "2GB")
            ("cores"  . 2)))
        ("samtools"
         . (("memory" . "128kB")
            ("cores"  . 1)))))))

(get config "locations" "output")

; => "/dev/null"

(get config "resources" "R" "cores")

; => 2
@end lisp

The variable @var{config} here is a so-called association list that
associates string keys with values.  Some of these values are again
association lists.  @code{get} simply traverses the provided path of
keys and ``enters'' each specified collection in turn.

Association lists are very common in Scheme, and they are also used as
an intermediate representation for many parsed files.  Here is an
example of using @code{get} on a parsed JSON file (this depends on the
@code{guile-json} package):

@lisp
;; Declare packages
require-packages
  . "guile-json"

;; Load it
import
  json

define config
  json-string->scm "\
@{
  \"locations\": @{
    \"input\": \"/home/rekado/foo\",
    \"output\": \"/dev/null\"
  @},
  \"resources\": @{
    \"R\": @{
      \"memory\": \"2GB\",
      \"cores\": 2
    @},
    \"samtools\": @{
      \"memory\": \"128kB\",
      \"cores\": 1
    @}
  @}
@}
"

get config "locations" "output"

; => "/dev/null"

get config "resources" "R" "cores"

; => 2
@end lisp

If the provided path cannot be followed because one or more of the
keys do not exist or the value after looking up an intermediate key
does not result in a collection, @code{get} will raise an error
condition.  If you only want to look up an optional value in a
collection that may or may not exist, you can provide a default value
to @code{get}.  That value will be returned instead of raising an
error.

@lisp
;; Declare packages
require-packages
  . "guile-json"

;; Load it
import
  json

define config
  json-string->scm "\
@{
  \"locations\": @{
    \"input\": \"/home/rekado/foo\",
    \"output\": \"/dev/null\"
  @},
  \"resources\": @{
    \"R\": @{
      \"memory\": \"2GB\",
      \"cores\": 2
    @},
    \"samtools\": @{
      \"memory\": \"128kB\",
      \"cores\": 1
    @}
  @}
@}
"

get config default: "/tmp" "locations" "temp-directory"

; => "/tmp"
@end lisp
@end deffn


@c *********************************************************************
@node Code Snippets
@chapter Code Snippets

@cindex scripts, embedding
@cindex code snippets
@cindex special syntax, code snippets
@cindex language support, code snippets
@cindex Python, code snippets
@cindex R, code snippets
@cindex shell snippets
The Guix Workflow Language is embedded in Guile Scheme, so it makes
sense to use Scheme to define the work that a process should perform.
Sometimes it may be more convenient, though, to express the procedure in
a different language, such as GNU R, Python, or maybe even in Bash.

The GWL provides special syntax for embedding code snippets.  The
special syntax is provided in the @code{(gwl sugar)} module, and is
loaded by default.  Here is an example of a process that runs an
embedded Bash shell script:

@lisp
process run-bash
  packages "bash"
  # bash @{ echo "hello from bash!" @}
@end lisp

Notice how the ``procedure'' field name was not used here, because the
code snippet came last.  This cuts down on boilerplate.

Code snippets are introduced with @code{# interpreter @{}, where
@code{interpreter} is the command line for running an interpreter, such
as @code{/bin/bash -c}.  Code snippets must end with a closing brace,
@code{@rbracechar{}}.

Make sure that the package inputs include a package providing the
interpreter.  For convenience we provide the special interpreters
@code{bash}, @code{R}, and @code{python}, so that you don't have to
specify a more complicated command line.  When no interpreter is
provided the generic shell interpreter @code{/bin/sh} will be used:

@lisp
process run-sh
  # @{ echo "hello from a shell!" @}
@end lisp

@cindex string interpolation, code snippets
@cindex accessing variables, code snippets
Within code snippets a special syntax is supported for accessing
variables.  Any uninterrupted value enclosed in double braces is
considered a reference to a variable, which may also be the name of
other process fields.  In the following example, the shell snippet
refers to the @code{name} and @code{inputs} fields of the current
process:

@lisp
process run-bash
  packages "bash"
  inputs
    . "a"
    . "b"
    . "c"
  # bash @{
    echo "The name of this process: @{@{name@}@}."
    echo "The data inputs are: @{@{inputs@}@}."
  @}
@end lisp

@cindex accessing named values in variables, code snippets
You can even access named or tagged values in lists.  In the following
example, the shell snippet refers to only selected values of the
@code{inputs} field of the current process:

@lisp
process run-bash
  packages "bash"
  inputs
    . "a"
    . mine: "b"
    . "c"
    . yours: "d"
  # bash @{
    echo "This is mine: @{@{inputs:mine@}@}, and this is yours: @{@{inputs:yours@}@}."
  @}
@end lisp

As expected, this will output the following text when run:

@example
This is mine: b, and this is yours: d.
@end example

@cindex accessing multiple named values, code snippets
You can also access tagged sub-lists with the @code{::} accessor:

@lisp
process frobnicate
  packages "frobnicator"
  inputs
    . genome: "hg19.fa"
    . samples: "a" "b" "c"
  outputs
    . "result"
  # @{
    frobnicate -g @{@{inputs:genome@}@} --files @{@{inputs::samples@}@} > @{@{outputs@}@}
  @}
@end lisp

This process will cause the following command to be executed:

@example
frobnicate -g hg19.fa --files a b c > result
@end example

If these two ways to access elements of a list are not enough, we
recommend defining a variable using @code{pick} (@ref{Useful procedures and macros}).
In the following example we define a variable @var{second-sample}
inside of the @code{procedure} field to hold the second of the inputs
after the keyword @code{samples:}, i.e. the string @code{the}.  We can
then refer to that variable by name in the code snippet.

@lisp
process foo
  inputs
    . "something"
    . samples: "in" "the" "way"
  procedure
    define second-sample
      pick second samples: inputs
    # @{ echo @{@{second-sample@}@} @}
@end lisp

@cindex environment variables, code snippets
@cindex process meta data, code snippets
You can also access process meta data through environment variables.
The following variables may be set:

@itemize
@item @code{_GWL_PROCESS_NAME}
@item @code{_GWL_PROCESS_SYNOPSIS}
@item @code{_GWL_PROCESS_DESCRIPTION}
@item @code{_GWL_PROCESS_INPUTS}
@item @code{_GWL_PROCESS_OUTPUT_PATH}
@item @code{_GWL_PROCESS_OUTPUTS}
@item @code{_GWL_PROCESS_COMPLEXITY_TIME}
@item @code{_GWL_PROCESS_COMPLEXITY_SPACE}
@item @code{_GWL_PROCESS_COMPLEXITY_THREADS}
@item @code{_GWL_PROCESS_VALUES}
@end itemize

@c *********************************************************************
@node Defining a Workflow
@chapter Defining a Workflow

@cindex defining a workflow
@cindex combining processes in a workflow

A workflow is a combination of processes that run in a certain order
or simultaneously.  You can specify the dependencies of processes
manually or let the GWL figure it out by matching up the declared
inputs and outputs of all processes.

A workflow definition will look something like this:

@lisp
workflow do-stuff
  processes
    . this
    . that
    . something-else
@end lisp

This defines a workflow with the name ``do-stuff'', binds it to a variable
@code{do-stuff}, and declares that it consists of the three processes
@code{this}, @code{that}, and @code{something-else}.  All of these
processes will be run at the same time.  This may not be what you want
when the processes depend on each other.

@cindex auto-connect, workflow order
If the processes all declare inputs and outputs, the GWL can connect
the processes and ensure that only independent processes are run
simultaneously.  Use the @code{auto-connect} procedure on your
processes:

@lisp
workflow do-stuff
  processes
    auto-connect
      . this
      . that
      . something-else
@end lisp

@cindex graph, workflow order
You can also explicitly construct a graph of processes with the aptly
named @code{graph} macro.  The following workflow definition lets the
process @code{combine} run after @code{generate-A} and
@code{generate-B}, which will both run in parallel.  The process
@code{compress} will run after @code{combine}, and thus at the very
end.

@lisp
workflow frobnicate
  processes
    graph
      combine -> generate-A generate-B
      compress -> combine
@end lisp


@node Declaring package requirements
@section Declaring package requirements
@cindex Declaring package requirements, workflows
@cindex Installing packages, workflows
@cindex Specify workflow environment
@cindex Require external features
@cindex require-packages, workflow declaration

Sometimes it may be desirable to use features from external packages
in the definition of the workflow.  For example, you may want to parse
a configuration file with Guile DSV before even defining any
processes.  Or perhaps you may need to use an application to prepare
state or query a database before the workflow is executed.

You can declare any package requirements with a
@code{require-packages} form at the very top of your workflow file.
This must be the first code expression after any commented lines.
Before a workflow file is evaluated, the current environment is
modified to make the specified packages available.  Any specified
Guile libraries are added to the load path, so care should be taken to
ensure that the libraries are in fact compatible with the version of
Guile used by the Workflow Language.

@cindex require-packages, declaration form
@deffn {Scheme Procedure} require-packages @var{package}@dots{}
The @code{require-packages} procedure takes any number of package
specifications.  A package specification is the package name,
optionally followed by @code{@@} and a version string.  The Workflow
Language guarantees that the declared packages will be available when
the workflow file is evaluated.

@lisp
;; Declare packages
require-packages
  . "guile-dsv"      ; for parsing CSV files
  . "guile-libyaml"  ; for parsing YAML files

;; Load them
import
  dsv
  yaml

;; Use them
define : load-config file
  if : file-exists? file
    read-yaml-file file
    error "Could not find configuration file!"
  @dots{}
@end lisp
@end deffn


@c *********************************************************************
@node Process Engines
@chapter Process Engines

@cindex executing processes
@cindex simple-engine, Process Engine
Once you have defined a workflow, there are different ways to run the
processes it consists of.  The simplest way is to turn the workflow into
a Guile script that sets up the desired environment and then executes
the workflow processes on the current machine.  This is what the
@code{simple-engine} does.

@cindex grid-engine, Process Engine
The @code{grid-engine} is similar to the @code{simple-engine} in that
it generates a shell script, with the difference that it also includes
resource variable definitions for submission to a Grid Engine
scheduling system.  The resource variables are derived from the
process @code{run-time} field.

@c *********************************************************************
@node Invoking guix workflow
@chapter Invoking @command{guix workflow}

The Guix Workflow Language extends your Guix installation with a new
command: @command{guix workflow}.  There are three sub-commands:

@table @code
@item run
To run (or prepare to run) a workflow from a file.
@item graph
Load a workflow from a file and generate a graph in Graphviz Dot-format.
@item web
The GWL includes a web interface.  This command starts it.
@end table

@node Options for guix workflow run
@section Options for @code{guix workflow run}

This is the command to run (or prepare to run) a workflow from a file.
It generate the process scripts, builds or downloads all dependencies,
and then runs the workflow process scripts corresponding to the
workflow defined in the given file.

The following options can be provided to change the behavior of this
command.

@table @code
@item --input=@var{name}[=@var{file}]
@itemx -i @var{name}[=@var{file}]
A workflow may have so-called free inputs, inputs that are not
provided by any of the workflow's processes.  By default, the GWL will
pick files from the current working directory that match the names of
free inputs.  This option can be used to map a @var{file} with an
arbitrary name to a free input in the workflow with the given
@var{name}.  This option can be provided more than once.

In the following example, the free input called @code{genome} is
mapped to the file @file{/data/hg19.fa} before running the workflow
defined in @file{analysis.w}:

@example
guix workflow run --input=genome=/data/hg19.fa analysis.w
@end example

@item --output=@var{location}
@itemx -o @var{location}
This option currently has no effect.

@item --engine=@var{engine}
@itemx -e @var{engine}
Select the process engine @var{engine} as the target of the generated
process scripts. See @ref{Process Engines}.

@c TODO: how does this differ from ``--dry-run''?
@item --prepare=@var{file}
@itemx -p @var{file}
Generate the process scripts and build or download all dependencies,
but do not run the workflow process scripts corresponding to the
workflow defined in @var{file}.

@item --log-events=@var{event},@dots{}
@itemx -l @var{events},@dots{}
Print messages for the comma-separated list of events.  This defaults
to logging the events @code{error}, @code{execute} (for fatal errors)
(for processes that are run), and @code{info} (for status
information).

@item --dry-run
@itemx -n
Prepare the scripts and the environments but don't actually run the
processes.  Only show what commands would be run.

@item --force
@itemx -f
Execute all processes, even if their outputs may have been cached from
previous runs.

@cindex container
@cindex user namespaces
@cindex isolate processes
@item --container
@itemx -c
Run each process inside of an isolated environment with file system
virtualization and user namespaces.  Only declared input files will be
available at execution time, and only declared output files will be
stored.  This is a great option to use when you want to make sure that
your processes only depend on state that you have declared.  A
downside is that generated output files cannot be written to the
target directories directly but are copied from the container to the
file system.
@end table

@node Options for guix workflow web
@section Options for @code{guix workflow web}

@table @code
@item --port=@var{port}
@itemx -p @var{port}
The network port on which the web interface listens for connections.

@item --host=@var{host}
@itemx -H @var{host}
The network host on which to listen for connections.  This defaults to
@code{localhost}.

@item --workflows-directory=@var{location}
This is a location containing other workflows that the web interface
may access to visualize them.
@end table

The following options are only rarely used:

@table @code
@item --max-file-size=@var{bytes}
The maximum size (in bytes) of files served by the web interface.

@item --dot=@var{/path/to/dot}
Use this to provide an alternative variant of the @file{dot} executable.

@item --root=@var{location}
Use this to override the root location of the workflow web interface.

@item --assets-directory=@var{location}
Use this to override the location of web assets (CSS, JavaScript,
images).

@item --examples-root-directory=@var{location}
Use this to override the default name of the directory containing
workflow examples.
@end table


@c *********************************************************************
@node Acknowledgments
@chapter Acknowledgments

Thanks to the following people who contributed to the Guix Workflow
Language through bug reports, patches, or through insightful
discussions:

@itemize @bullet
@item Ludovic Courtès @email{ludo@@gnu.org}
@item Simon Tournier
@item Kyle Meyer @email{kyle@@kyleam.com}
@end itemize

Also thanks to the people who reviewed this project for joining the GNU
project.

@itemize @bullet
@item Mike Gerwitz @email{mtg@@gnu.org}
@end itemize

Thank you.

@c *********************************************************************
@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@page

@c *********************************************************************
@node Concept Index
@unnumbered Concept Index

@printindex cp

@node Programming Index
@unnumbered Programming Index
@syncodeindex tp fn
@syncodeindex vr fn
@printindex fn

@bye
