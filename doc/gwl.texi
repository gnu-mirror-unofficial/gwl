\input texinfo
@c -*-texinfo-*-

@c %**start of header
@setfilename gwl.info
@documentencoding UTF-8
@settitle Guix Workflow Language Reference Manual
@c %**end of header

@include version.texi

@copying
Copyright @copyright{} 2018 Roel Janssen@*
Copyright @copyright{} 2018, 2019 Ricardo Wurmus

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end copying

@dircategory Scientific Computing
@direntry
* Guix Workflow Language: (gwl).  Reproducible Scientific Workflows based on Guix.
@end direntry

@titlepage
@title Guix Workflow Language Reference Manual
@subtitle Reproducible Scientific Workflows based on Guix
@author The developers of the GNU Guix Workflow Language

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@value{UPDATED} @*

@insertcopying
@end titlepage

@contents

@c *********************************************************************
@node Top
@top Guix Workflow Language

This document describes the Guix Workflow Language version @value{VERSION}.

@menu
* Introduction::                What is this all about?
* Installation::                Installing the GWL.
* A Simple Workflow::           Show me what this looks like!
* Code Snippets::               Embedding scripts
* Process Engines::             Generating executable pipeline scripts.

* Acknowledgments::             Thanks!
* GNU Free Documentation License::  The license of this manual.
* Concept Index::               Concepts.
* Programming Index::           Data types, functions, and variables.
@end menu

@c *********************************************************************
@node Introduction
@chapter Introduction

This package provides the @dfn{Guix Workflow Language} (GWL), a
scientific computing extension to the Guix package manager.  It combines
the specification of work units and their relationship to one another
with the reproducible software deployment facilities of the functional
package manager GNU Guix.

In the GWL there are two concepts we need to know about: processes and
workflows.  We describe a computation (running a program, or evaluating
a Scheme expression) using a process.  A workflow describes how multiple
processes relate to each other (e.g. ``process B must run after process
A, and process C must run before process A'').

To make processes and workflows available to the GWL via Scheme or the
command line, we write them as @ref{Creating Guile Modules,,,guile,
Guile Scheme modules}.  Processes or workflows can be run
programmatically using the @code{process->script->run} and
@code{workflow-run} procedures, or on the command line by using the
@code{guix process} and @code{guix workflow} commands.


@c *********************************************************************
@node Installation
@chapter Installation

The Guix Workflow Language uses the GNU build system.  To install it
from a release tarball just unpack it and run the usual commands:

@cindex installing from source
@cindex building from source
@example
./configure
make
make install
@end example

If you want to build the sources from the source repository you need to
bootstrap the build system first.  Run @code{autoreconf -vif} first and
then perform the above steps.


@c *********************************************************************
@node A Simple Workflow
@chapter A Simple Workflow

To get a little taste of what the workflow language looks like, let's
start by writing a simple workflow.

Here is a simple workflow example:

@example
@verbatiminclude examples/simple-wisp.w
@end example

This white-space sensitive syntax is called Wisp and if your familiar
with Python or YAML you should feel right at home.  To use this syntax
simply save your workflow to a file ending on @file{.w}, @file{.wisp},
or @file{.gwl}.

The workflow language really is a @dfn{domain specific language} (DSL)
embedded in Guile Scheme, so if you're a Lisper you may prefer to write
your workflows directly in Scheme while basking in its parenthetical
glow:

@example
@verbatiminclude examples/simple.scm
@end example

Everything you can express in Scheme can also be expressed with the Wisp
syntax, so the choice is down to personal preference.


@c *********************************************************************
@node Code Snippets
@chapter Code Snippets

@cindex scripts, embedding
@cindex code snippets
@cindex special syntax, code snippets
@cindex language support, code snippets
@cindex Python, code snippets
@cindex R, code snippets
@cindex shell snippets
The Guix Workflow Language is embedded in Guile Scheme, so it makes
sense to use Scheme to define the work that a process should perform.
Sometimes it may be more convenient, though, to express the procedure in
a different language, such as GNU R, Python, or maybe even in Bash.

The GWL provides special syntax for embedding code snippets.  The
special syntax is provided in the @code{(gwl sugar)} module.  Here is an
example of a process that runs an embedded Bash shell script:

@example
import
  gwl processes
  gwl sugar

process: run-bash
  package-inputs "bash"
  procedure # bash @{ echo "hello from bash!" @}
@end example

Code snippets are introduced with @code{# interpreter @{}, where
@code{interpreter} is the command line for running an interpreter, such
as @code{/bin/bash -c}.  Make sure that the package inputs include a
package providing the interpreter.  For convenience we provide the
special interpreters @code{bash}, @code{R}, and @code{python}, so that
you don't have to specify a more complicated command line.

Code snippets must end with a closing brace, @code{@rbracechar{}}.

@cindex string interpolation, code snippets
@cindex accessing variables, code snippets
Within code snippets a special syntax is supported for accessing
variables.  Any uninterrupted value enclosed in double braces is
considered a reference to a variable, which may also be the name of
other process fields.  In the following example, the shell snippet
refers to the @code{name} and @code{data-inputs} fields of the current
process:

@example
import
  gwl processes
  gwl sugar

process: run-bash
  package-inputs "bash"
  data-inputs
    . "a"
    . "b"
    . "c"
  procedure # bash @{
    echo "The name of this process: @{@{name@}@}."
    echo "The data inputs are: @{@{data-inputs@}@}."
  @}
@end example

@cindex accessing named values in variables, code snippets
You can even access named or tagged values in lists.  In the following
example, the shell snippet refers to only selected values of the
@code{data-inputs} field of the current process:

@example
import
  gwl processes
  gwl sugar

process: run-bash
  package-inputs "bash"
  data-inputs
    . "a"
    . #:mine
    . "b"
    . "c"
    . #:yours "d"
  procedure # bash @{
    echo "This is mine: @{@{data-inputs:mine@}@}, and this is yours: @{@{data-inputs:yours@}@}."
  @}
@end example

As expected, this will output the following text when run:

@example
This is mine: b, and this is yours: d.
@end example

@cindex environment variables, code snippets
@cindex process meta data, code snippets
You can also access process meta data through environment variables.
The following variables may be set:

@itemize
@item @code{_GWL_PROCESS_NAME}
@item @code{_GWL_PROCESS_SYNOPSIS}
@item @code{_GWL_PROCESS_DESCRIPTION}
@item @code{_GWL_PROCESS_DATA_INPUTS}
@item @code{_GWL_PROCESS_OUTPUT_PATH}
@item @code{_GWL_PROCESS_OUTPUTS}
@item @code{_GWL_PROCESS_COMPLEXITY_TIME}
@item @code{_GWL_PROCESS_COMPLEXITY_SPACE}
@item @code{_GWL_PROCESS_COMPLEXITY_THREADS}
@end itemize

@c *********************************************************************
@node Process Engines
@chapter Process Engines

@cindex executing processes
@cindex simple-engine, Process Engine
Once you have defined a workflow, there are different ways to run the
processes it consists of.  The simplest way is to turn the workflow into
a Guile script that sets up the desired environment and then executes
the workflow processes on the current machine.  This is what the
@code{simple-engine} does.

@cindex grid-engine, Process Engine
The @code{grid-engine} is similar to the @code{simple-engine} in that it
generates a shell script, with the difference that it also includes
resource variable definitions for submission to a Grid Engine scheduling
system.  The resource variables are derived from the process complexity
field.

@c *********************************************************************
@node Acknowledgments
@chapter Acknowledgments

Thanks to the following people who contributed to the Guix Workflow
Language through bug reports, patches, or through insightful
discussions:

@itemize @bullet
@item Ludovic Court√®s @email{ludo@@gnu.org}
@item Simon Tournier
@item Kyle Meyer @email{kyle@@kyleam.com}
@end itemize

Also thanks to the people who reviewed this project for joining the GNU
project.

@itemize @bullet
@item Mike Gerwitz @email{mtg@@gnu.org}
@end itemize

Thank you.

@c *********************************************************************
@node GNU Free Documentation License
@appendix GNU Free Documentation License

@include fdl-1.3.texi

@page

@c *********************************************************************
@node Concept Index
@unnumbered Concept Index

@printindex cp

@node Programming Index
@unnumbered Programming Index
@syncodeindex tp fn
@syncodeindex vr fn
@printindex fn

@bye
